# AINE (AI Native Engineering)

## 一句话定位

**为"不确定计算主体"设计的工程体系**

---

## AINE 的真正目标：不是更好地复刻今天的软件

### 需要避免的两个极端

| 极端 | 误解 | 问题 |
|------|------|------|
| **极端 A** | AINE = AI 取代人写今天的代码 | 停留在旧范式，只是把"人写"换成"AI 写" |
| **极端 B** | AINE = 只适用于 greenfield 新项目 | 否定现有系统价值，无法证明工程级成功 |

**我们需要的是折衷但面向未来的软件架构**

> 约束性要求：必须能 AINE 化 Blocklet Server（用复杂 legacy 系统验证）

### 马车与汽车的类比

如果站在马车时代思考未来，但所有问题仍围绕如何让马车跑得更快、更稳、甚至自动驾驶，最终得到的只会是"更先进的马车"。

**真正的变化**：
- 不是发生在马车本身
- 而是发生在道路、交通系统、规则和基础设施上
- **需求对象本身发生了改变**

### 软件正在经历类似的变化

**传统软件工程的前提**：
- 软件是由人类写出的确定性运行代码组成的系统
- 界面是预先设计和实现的
- 逻辑需要被完整定义、可预测、可覆盖所有路径

**AI-native 系统中，这个前提正在失效**：
- 界面不一定需要被"写出来"，可以运行阶段根据上下文生成
- 大量原本需要固化在代码里的逻辑，可以由规则、上下文和模型在执行过程中完成
- 人类写下的确定性代码，正在退化为**支撑环境**，而不再是系统主体

> 这不是能力的退化，而是**复杂度分布方式的变化**

### AINE 的价值

**不是**：让 AI 更像人一样去写代码

**而是**：帮助我们识别——哪些东西本来就不应该再由人类提前写死

### 对两个极端的澄清

**关于"全是 greenfield"**：
- 我们不是否定现有系统、现有基础设施的价值
- 运行环境、隔离机制、约束条件——越稳定，越适合用传统工程甚至人工方式实现
- 一旦环境被固定，上层系统反而可以更自由、更生成式
- 真正需要重新思考的：**应用层本身的复杂度是否还有存在的必要**

**关于"让 AI 写今天的代码"**：
- 如果目标仍是复刻现有软件结构，只会保留旧时代的复杂性
- AI-native 转型中，语言切换、架构切换不应该是等比例翻译
- 而是**结构性重写**：很多复杂度应该被永久删除，而不是被保留下来等待 AI 处理

### Scaffold 的正确理解

**Scaffold 不是**：
- ❌ 兼容旧代码、包裹旧系统的万能适配层
- ❌ 指望 AI 自动把旧系统"无痛升级"

**Scaffold 是**：
- ✓ 定义未来软件形态的架构方式
- ✓ 一旦架构定义清楚，现有系统是否迁移、如何迁移，都可以是人工决策的结果

### AINE 真正关注的问题

不是"AI 能不能把今天的软件写得更好"

**而是**：
- 在 AI 作为运行时参与者的前提下，软件哪些结构已经不再成立？
- 哪些确定性仍然必须保留？
- 哪些复杂度可以被推迟到运行阶段，甚至被完全删除？

> 当我们用这个问题框架思考时，AINE 的难度反而会下降——因为我们不再试图提前定义一切

### 判断标准

| 设计方向 | 站在哪个时代 |
|---------|------------|
| 更完整地复刻现有系统、更严格地约束 AI、让 AI 适配旧结构 | 旧时代的软件需求 |
| **减少必须写死的部分、把变化和判断交给运行期、让系统在规则和上下文中自然生长** | **AI Native Engineering** |

### 核心结论

> **AINE 不是一次更高效的自动化，而是一次对软件工程边界的重新定义。**
>
> 真正的挑战不在于 AI 能不能写代码，而在于我们是否愿意**放弃一些已经不再必要的确定性**。

---

## 不是什么

- ❌ PPT / 方法论文档
- ❌ workflow
- ❌ prompt 工程
- ❌ Agile for AI

## 是什么

一个工程体系，解决：
- AI 如何参与工程而不破坏工程
- 不确定性如何被系统吸收
- 人类工程师如何与 Agent 协作
- Legacy system 如何被 AI 接管而不推倒重来

## 核心阶段

非严格 pipeline：

1. **Intent** - 意图
2. **Context** - 上下文
3. **Contract** - 自然语言可执行约定
4. **Chamber** - 受限运行空间
5. **Build / Run / Ops** - 构建运行运维
6. **Feedback / Readback / Replay** - 反馈回读重放

**Readback / Replay / Diff 非常重要——这是工程，不是"对话"**

## 四大组件

| 组件 | 说明 | 实现状态 |
|------|------|----------|
| **AFS** | "Everything is Context" 的文件系统抽象 | 基础已实现 |
| **Chamber Runtime** | Agent 运行时环境 | 原型阶段 |
| **Build Compiler** | 构建编译器 | 原型阶段 |
| **AIGNE 框架** | Agent 开发框架 | 已发布开源 |

## 两层复杂度分离

| 层次 | 内容 | 工程难度 | 做法 |
|------|------|---------|------|
| **平台层** | AFS, ArcSphere, Agent Fleet, LLM runtime | 高（传统工程） | 一次性做好，固化 |
| **应用层** | Skills + 规则 + 生成式 UI | 低（声明式） | 用户/AI 自己组合 |

**确定性从"应用代码"下沉到"平台层"**

## Contract 范式

| 传统智能合约 | AI 时代的 Contract |
|-------------|-------------------|
| 过程性（if-then-else） | 声明性（规则/约束） |
| 执行者：EVM | 执行者：LLM + Chamber |
| 编译执行 | 解释执行 |

**Contract = Constraint，不是 Procedure**

## 与 AFS 的关系

- AINE = 方法论 / 工程范式
- AFS = 运行时的现实约束
- **没有 AFS，AINE 只是 workflow；有了 AFS，AINE 才是 system**

### Intent / Contract / Chamber 与 AFS

- Intent 本身可以是 AFS 文件
- Contract 可以是自然语言文件
- Chamber 输入输出全部落在 AFS
- 反对 Chamber 只靠 prompt string 或内存变量传状态

## 学术认可

- 已有论文被 **ICSA 2026** 接收

## 验证计划

- 用 Blocklet Server 作为验证案例
- 分 10 步实施：从 Intent 重构到 AI 驱动重构，最终完成系统重写

---

## AI-Native 软件开发过程愿景

> Human-Intent × AI-Structure × Deterministic Execution

**核心转变**：
- 人类负责：意图与体验
- AI 负责：结构与实现
- Build Compiler 负责：确定性集成

### 五个阶段

#### 1. Intent Layer（意图层 — 人类主导）

软件核心来源于人类的意图、哲学与体验目标：
- 提出产品愿景
- 描述目标与使用场景
- 阐明体验原则、价值观、审美取向
- 与 AI 讨论、澄清、提问
- 梳理"为什么要做这件事"

> AI 的角色是协助澄清、挑战、补充，但绝不取代"带有灵魂的创造性工作"

#### 2. Experience Layer（体验层 — 人类核心，AI 扩展）

开发者编写少量核心 User Stories，AI 会：
- 扩展更多 user stories
- 补全边缘情况
- 自动检查遗漏
- 发现潜在模式与风险
- 验证意图是否自洽

最终形成完整的"用户体验地图"

#### 3. Semantic Decomposition（语义分解 — AI 主导，人类把关）

- 人类给出高层模块边界与系统轮廓
- AI 自动将语义分解为 Chamber（最小语义模块）
- 自动生成模块依赖关系（DAG）
- 自动分析数据流、行为流
- 自动优化模块边界与职责
- 自动发现重复或缺失的语义单元

> 人类只需判断：语义是否正确、是否符合愿景

#### 4. AFS Structure & Scaffold（语义结构 — AI 自动）

AI 基于语义结构生成：
- 完整的 AFS 目录结构
- 每个 Chamber 的 contract 与 metadata
- 示例输入输出（Examples）
- mock 数据与测试骨架
- 全局一致性检查（是否覆盖所有 user story）

> 这一阶段产物 = 软件的"语义图纸"

#### 5. Implementation（实现层 — AI 完全执行）

AI 在完全隔离的 Chamber 环境中：
- 生成 `code.ts`（纯函数实现）
- 自动编写单元测试
- 自动运行与修复（Auto-TDD）
- 对照 contract 进行一致性校验
- 与其他 Chamber 语义比对
- 生成最终高质量、可验证的模块

> 人类只需在"语义冲突"时介入判断

最终 Build Compiler：
- 自动 glue 所有 Chamber
- 自动依赖集成
- 自动生成可执行系统
- 保证 **deterministic build**

### 角色分工总结

| 层次 | 主导者 | 职责 |
|------|--------|------|
| Layer 1-2 | 人类 | 愿景、意图、体验、结构哲学 |
| Layer 3-5 | AI | 语义分解、模块化结构、实现与验证 |
| 最终构建 | 系统 | 自动 glue、测试、确定性构建 |

### 建筑设计隐喻

```
人类 = 建筑师：设计蓝图、空间逻辑、意图和体验
AI = 工程师：工程、建造与结构优化
Build Compiler = 施工方：施工与验收
```

> 让软件从手工劳动转向语义驱动的工程学

---

## Chamber 详解

Chamber 是 AI 原生框架的基本代码构造单元，核心在于实现**函数级/模块级硬隔离**，解决 AI 大规模工程中的全局上下文爆炸和跨模块污染问题。

### 定义演进

| 版本 | 定义 | 问题 |
|------|------|------|
| 原始 | 函数级隔离，每个函数是独立房间 | 文件系统碎片化，工程过于繁琐 |
| **修正** | 小模块（Micro-module），可含多个 Private Helpers | 提升高内聚，提高 AI 局部上下文质量 |

> Chamber 支持递归式分形开发：高级别 Chamber 可递归拆解为子 Chambers

### AFS 文件夹结构

每个 Chamber = AFS 中的一个独立文件夹：

```
chamber-name/
├── code.ts          # 函数逻辑（AI 生成）
├── contract.json    # Public API 定义（接口+输入输出结构）
├── tests/           # 自动生成的测试用例
├── mocks/           # 模拟执行环境
├── meta.json        # 版本、历史等元数据
└── build/           # 编译产物
```

**类比**：硬隔离的面向对象
- 文件夹 = Class/Package（封装体）
- contract.json = Interface（公共契约）
- code.ts = Implementation（私有实现）

### Chamber Runtime

隔离的沙箱执行环境，是 Chamber 隔离性的物理保证。

**技术实现**：Node.js `vm2` 或 `worker_threads`

**特性**：
- AI 生成的函数可安全执行、测试、验证契约
- 完全隔离，不可读写其他 Chamber
- 防止 AI "越界修改"或产生副作用

**纯函数式要求**：
- 所有状态都在输入参数里
- 引用透明（Referential Transparency）
- 完美契合沙箱设计和 Auto-TDD

---

## Build Compiler 详解

Build Compiler 是框架的工程质量核心保障，负责自动化模块集成，实现**"集成永远不会坏"**。

### 核心职责

| 职责 | 说明 |
|------|------|
| **AI 不写 Glue** | AI 不编写 import/export、路由注册、模块装配 |
| **自动生成 Glue** | 读取 AFS 结构，自动拼装 Chambers 成 TS/JS 模块 |
| **DI 自动化** | 扫描 Chamber 文件夹，编译时生成依赖注入代码 |
| **确定性保障** | 模块连接（Wiring）是确定性的 |

### 零成本抽象（Zero-Cost Abstraction）

解决隔离性与性能之间的矛盾：

| 阶段 | Chamber 状态 | 目标 | Build Compiler 角色 |
|------|-------------|------|-------------------|
| **开发/验证期** | 物理隔离（高开销） | AI 代码安全可验证 | 隔离执行 Chamber |
| **构建/生产期** | 静态链接（零开销） | 商业级性能 | 静态链接 + 内联优化 |

**结果**：
- 对 AI：微服务架构（便于理解和生成）
- 对 CPU：高度优化的单体应用（无 IPC/上下文切换开销）

> Build Compiler 就像 C++ 编译器：构建完成后，Chamber 隔离墙被拆除，模块调用变成纯函数调用

### 在测试中的作用

- 组装模块，确保 Glue 层确定性
- 自动运行 Integration Test

### 核心洞察

```
Chamber = AI 友好的"助记符"（便于 AI 编写）
Build Compiler = 编译成"机器码"（全速运行）
```

---

## AINE 方法论闭环

### 核心出发点：让 AI 成为「一线工程师」

| 传统做法 | AINE |
|---------|------|
| 人类负责架构、编码、测试 | 人类负责定义意图、设计边界 |
| AI 只是辅助写点代码 | AI 在约束内完成绝大部分实现与回归 |

**三个关键问题**：
1. 如何收集和表达意图（Intent）
2. 如何把复杂系统拆成 AI 能搞定的模块
3. 如何通过 Chamber/Scaffold 把模块安全拼回可运行系统

### Intent 优先

**Intent 不是需求文档的复述**，而是对「系统应该如何行为」的精细化描述：
- 入口和出口：输入是什么、输出是什么
- 业务语义：在什么情况下应该怎么响应
- 正常路径 + 异常路径
- 约束条件：安全性、性能、边界条件

**好的 Intent**：
- 丢给 AI，能据此给出合理的设计与实现方案
- 丢给人，也能看懂并给出架构 review

**Intent 的双重角色**：
1. **作为设计输入**：AI 输出模块划分 → 与人类划分对比 → 融合
2. **作为测试基础**：从 Intent 直接推导测试用例，TDD 与 Intent 一体

> AINE 的第一步从来不是「写代码」，而是磨 Intent

### Intent 收集方法论

**两种根本不同的情况**：

| 情况 | 方法 | 原因 |
|------|------|------|
| **全新软件** | Interview 方法 | 从宏观 idea 开始，AI 通过提问引导用户澄清 |
| **已存在系统** | Reverse Engineering | 人的描述与实际系统存在偏离，interview 会导致 intent 与现有系统差距越来越大 |

**观察优于询问的原理**：
- 用户不知道自己真正要什么
- 用户无法清楚解释自己在做什么
- AI 作为统一观察者具有稳定人格

**Reverse Engineering 方法**：
- 通过界面截图/Visual 让 AI "看到" 系统
- 让 AI 直接阅读现有代码（经过人工标注整理）
- AI 消化文档、API 接口、过去讨论、说明书
- 观察完成后再进行适当提问

**内容权重设置**：

| 内容类型 | 权重 | 原因 |
|---------|------|------|
| 代码实现 | 最高 | 唯一的 ground truth |
| 用户文档 | 较高 | 对外形式 |
| 客户 FAQ/Q&A | 高 | 实战来源 |
| 早期设计文档 | 较低 | 可能已过时 |
| 外部报道 | 小心 | 可能偏离和错觉 |

**三种方法结合**：
1. Interview（完全 greenfield）
2. Reverse Engineering（现有系统）
3. Speech/文章 + Q&A（结构化想法 + 后续澄清）

### Intent 收集的工程化

**更容易喂给工具**：
- 大段文章
- 链接
- Copy/paste
- 界面、结构草图（Vision model 可处理）

**语音输入优化**：
- 语音的上下文更多
- 每个语音建议先给用户 review，防止录入错误导致 LLM 混乱

**版本和回放能力**：
- 删除比修改的语义分歧更小
- 删除本身也必须可追溯
- 需要版本管理 built-in（LLM 全自动控制）
- 有版本后回放不需要从头开始，可回退到任意点
- LLM 不确定性导致回放结果不确定，但有版本管理后可以对每个成果进行 Diff

### 核心洞察

> **Intent 就是 AINE 时代的源代码**
>
> 把 Intent 收集工程化，使其更像软件源代码管理

---

## 语音作为高价值 Context 捕获系统

> 从"输入方式"升级为"Context Engineering 的前置系统"

在 AINE 体系中，语音输入的目标不是"更快地把声音变成文字"，而是为大域模型构造可工作的、高置信度的上下文输入。

### 一、前期处理：让语音成为"可被模型消费"的输入

语音的天然形态是混乱的、探索式的、不可编辑的。如果只做语音识别（ASR），得到的只是大量未经整理的 transcript，这对大域模型而言价值极低，甚至会放大噪声。

**语音输入系统必须在"进入大域模型之前"完成一层前期处理**，其目标不是生成结论，而是构造稳定的上下文结构。

**前期处理三原则**：

| 原则 | 说明 |
|------|------|
| **事实优先** | 原始录音与全量 transcript 必须完整保留，作为不可覆盖的事实层，为后续任何重算、回溯和校正提供基础 |
| **整理而非总结** | AI 的第一步不是"给结论"，而是对 transcript 进行整理：话题切分与语义分段、冗余压缩与口语噪声处理、初步 intent 提取与不确定点标注。产出是"可操作的 context"，不是"最终表达" |
| **允许人类校正** | 系统必须允许用户对整理结果进行轻量校正，用于标注重点、确认意图、删除随口表达。这不是改错字，而是在为模型提供高置信度语义锚点 |

> 只有经过这一层处理，语音输入才配得上作为大域模型的有效输入

### 二、静默提升（Silent Augmentation）

在语音交互中，最大的体验杀手不是识别错误，而是**被打断的思考流**。

AINE 时代的语音系统不应以"实时插话"为主要交互方式，而应采用**静默提升**的设计理念。

**静默提升核心原则**：

| 原则 | 说明 |
|------|------|
| **不打断讲话流程** | AI 不插话、不追问、不强行引导 |
| **在后台持续理解与提示** | AI 通过屏幕、侧栏或非侵入方式，提供：潜在追问建议、话题偏移提醒、结构化引导线索 |
| **由人决定是否采纳** | AI 提供的是"主持人级别的提示"，而不是"自动驾驶" |

**Panel Discussion 隐喻**：

这种机制类似 panel discussion 中的主持人——帮助讲话者保持结构、回到主题、激发更完整的表达，但永远不替代人本身的思考与判断。

### 三、总结性判断

| 问题 | 解决方案 |
|------|---------|
| 语音如何从"混沌表达"变成"可工作的上下文" | 前期处理 |
| AI 如何在不破坏人类思考流的前提下持续提升表达质量 | 静默提升 |

> **语音输入在 AINE 时代应是一个 Context Engineering 的前置系统，而不是一个语音识别功能**

---

### Scaffold：带着 Mock 也能跑

**现实问题**：今天的工程对 AI 极不友好
- 模块之间紧耦合：删一个目录，整个服务起不来
- AI 一脚踩在任何地方，都可能把整栋楼弄塌

**Scaffold 类比 RPC Stub/Mock**：
- 每个模块都有「最小可运行的 Mock 实现」
- 整个程序在全部用 Mock 时就能编译通过并跑起来

**具体做法**：
```
xxx.scaffold / xxx.mock  → 定义接口和默认行为（假实现）
xxx.impl                 → 真实实现
```
- 如果 impl 不存在或编译失败，自动回退到 mock
- 任何模块可被「抽掉」，系统仍能启动

### Chamber：AI 的隔离工作舱

**Chamber 组成**：
1. **Contract（契约）**：输入输出类型 + 行为约定
2. **Test（测试用例）**：根据 Contract 生成正反向用例
3. **Implementation Space**：唯一允许 AI 修改代码的地方

**Chamber 约束**：
- AI 不允许越界访问其他模块的实现
- 只能依赖 Contract 和测试结果来迭代

**Chamber 填满条件**：
- 所有测试跑通
- 可以在带 Scaffold 的整体系统中集成运行
- Mock 被真实实现替换

### 递归分解

**顶层**：Intent → 模块划分
- AI 输出模块列表、依赖关系、职责边界
- 人类 Review：与自己的架构设计对比

**中层**：模块内部再细分
- 子 Intent → 子 Chamber
- 找到当前模型能力刚好的粒度

**底层**：AI 全自动完成的单元
- 给定 Contract + 测试，AI 独立完成
- 人类只做少量 Review

### 渐进替换策略

- 部分模块彻底 AI 重写
- 部分模块继续沿用旧代码
- 先替换「最容易 AI 重写」的模块
- 对「AI 暂时搞不定」的保留人工维护路径

### 团队结构：T0 / F0

| 角色 | 职责 |
|------|------|
| **T0（开路先锋）** | 定义 AINE 工具链、率先试点、总结模式 |
| **F0（守门人）** | Bugfix、安全更新、依赖升级、保证稳定 |

> 如果没有人稳定守住现有收入和客户，T0 再有远景也没用

### 方法论闭环

```
1. Intent（结构化意图）
   ↓
2. Design & Decomposition（AI+人类 架构设计）
   ↓
3. Chamber & Scaffold（隔离舱 + 可运行脚手架）
   ↓
4. Recursive Implementation（递归到 AI 能全自动完成的粒度）
   ↓
5. Integration & Build（渐进替换，始终可构建）
   ↓
6. Team Structure（T0/F0 保障推进节奏与稳定性）
```

> 用真实复杂项目倒逼 AINE 工具链成熟，再用成熟的 AINE 工具链改造更多项目

---

## Agent 摘要

```
AINE is engineering for non-deterministic computational actors.
Not workflow, not prompt engineering, not Agile for AI.
Core phases: Intent, Context, Contract, Chamber, Build/Run/Ops, Feedback.
Readback/Replay/Diff are crucial - this is engineering, not conversation.
Without AFS, AINE is just workflow; with AFS, AINE is a system.
Contracts are constraints, not procedures.
Determinism sinks from application layer to platform layer.
```
